import { JaegerClient } from '../client';
import { FindTracesResponse } from '../domain';
import { Tool } from './types';

import { z } from 'zod';
import { Server } from '@modelcontextprotocol/sdk/server/index.js';

export class FindTrace implements Tool {
    name(): string {
        return 'find-trace';
    }

    description(): string {
        return 'Finds a single trace matching your criteria. Returns the trace in OpenTelemetry resource spans format.';
    }

    paramsSchema() {
        return {
            serviceName: z
                .string()
                .describe('Service name captured in Jaeger. Discover available services first to get valid service names. This will be used to filter traces generated by the specified service.'),
            operationName: z
                .string()
                .describe(
                    'Operation name for the specified service. Discover available operations for a service to get valid operation names. This will be used to filter traces by the specified operation/span name.'
                )
                .optional(),
            attributes: z
                .string()
                .describe(
                    'Filters spans by span attributes. ' +
                        'Attributes should be passed as a comma-separated list of key=value pairs. ' +
                        'Values can be strings, numbers, or booleans. ' +
                        'For example: "stringAttribute=str,integerAttribute=123,doubleAttribute=123.456,booleanAttribute=true"'
                )
                .optional(),
            startTimeMin: z
                .string()
                .datetime()
                .describe(
                    'Start of the time interval (inclusive) for the query. ' +
                        'Only traces with spans that started on or after this time will be returned. ' +
                        'The HTTP API uses RFC 3339, section 5.6 format (e.g., "2017-07-21T17:32:28Z").'
                ),
            startTimeMax: z
                .string()
                .datetime()
                .describe(
                    'End of the time interval (exclusive) for the query. ' +
                        'Only traces with spans that started before this time will be returned. ' +
                        'The HTTP API uses RFC 3339, section 5.6 format (e.g., "2017-07-21T17:32:28Z").'
                ),
            durationMin: z
                .number()
                .positive()
                .describe(
                    'Minimum duration of a span in milliseconds. This will be used to filter traces containing spans that lasted at least this long.'
                )
                .optional(),
            durationMax: z
                .number()
                .positive()
                .describe(
                    'Maximum duration of a span in milliseconds. This will be used to filter traces containing spans that lasted at most this long.'
                )
                .optional(),

        };
    }

    private _normalizeAttributes(attributes: string): { [k: string]: string } {
        const normalizedAttributes: { [k: string]: string } = {};
        if (attributes && attributes.trim()) {
            const pairs = attributes.split(',');
            for (const pair of pairs) {
                const [key, value] = pair.split('=', 2);
                if (key && value !== undefined) {
                    normalizedAttributes[key.trim()] = value.trim();
                }
            }
        }
        return normalizedAttributes;
    }

    async handle(
        server: Server,
        jaegerClient: JaegerClient,
        {
            serviceName,
            operationName,
            attributes,
            startTimeMin,
            startTimeMax,
            durationMin,
            durationMax,
        }: any
    ): Promise<string> {
        const response: FindTracesResponse = await jaegerClient.findTraces({
            query: {
                serviceName,
                operationName,
                attributes: this._normalizeAttributes(attributes),
                startTimeMin: startTimeMin,
                startTimeMax: startTimeMax,
                durationMin,
                durationMax,
                searchDepth: 1,
            },
        });
        return JSON.stringify(response.resourceSpans || {});
    }
}
